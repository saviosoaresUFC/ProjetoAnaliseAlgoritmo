<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Modelo de uso do MathJax (HTML+Latex)</title>

    <!-- MATHJAX 3 (através da CDN) -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- MATHJAX 3 (salvo no computador) -->
    <!-- <script type="text/javascript" async src="../../../Aplicativos/MathJax-master/es5/tex-mml-chtml.js" async></script> -->
</head>

<body>

    <h1>Avaliação Continuada 02 (Provando corretude de algoritmos iterativos)</h1>
    <hr>

    <h2>Questão 1</h2>
    <p><strong>Invariante</strong>: Antes de cada iteração do laço <code>for</code> (antes de comparar \( j \) com \( n
        \)), <code>maximum</code> contém o maior valor de \( A[1 \dots j-1] \).</p>

    <p><strong>Caso Base</strong>: Para \( j = 2 \), <code>maximum = A[1]</code>. Subvetor \( A[1 \dots 1] = \{A[1]\}
        \), <code>maximum</code> é o maior. Válido.</p>

    <p><strong>Passo Indutivo</strong>: Suponha que <code>maximum</code> é o maior de \( A[1 \dots j-1] \).<br>
        - Se <code>maximum < A[j]</code>, <code>maximum = A[j]</code>, maior de \( A[1 \dots j] \).<br>
        - Se <code>maximum ≥ A[j]</code>, <code>maximum</code> é maior de \( A[1 \dots j] \).<br>
        Para \( j+1 \), <code>maximum</code> é maior de \( A[1 \dots j] \). Válido.</p>

    <p><strong>Término</strong>: Para \( j = n \), <code>maximum</code> é maior de \( A[1 \dots n-1] \).<br>
        - Se <code>maximum < A[n]</code>, <code>maximum = A[n]</code>, maior de \( A[1 \dots n] \).<br>
        - Se <code>maximum ≥ A[n]</code>, <code>maximum</code> é maior de \( A[1 \dots n] \).<br>
        Retorna o maior de \( A[1 \dots n] \).</p>

    <hr>

    <h2>Questão 2</h2>
    <p><strong>A.</strong> Mostrar que \( A' \) é permutação de \( A \).</p>

    <p><strong>B. Invariante (linhas 2–4)</strong>: Para \( j \leq k \leq A.length \), \( A[k] \geq A[j-1] \).</p>

    <p><strong>Prova</strong>:<br>
        1. <strong>Caso Base</strong>: Para \( j = A.length \), \( A[A.length] \geq A[A.length-1] \). Válido.<br>
        2. <strong>Passo Indutivo</strong>: Suponha que vale para \( j \).<br>
        - Se \( A[j] < A[j-1] \), troca garante \( A[j] \geq A[j-1] \).<br>
            - Se \( A[j] \geq A[j-1] \), sem troca. Para \( j-1 \), \( A[k] \geq A[j-2] \). Válido.<br>
            3. <strong>Término</strong>: Para \( j = i+1 \), \( A[k] \geq A[i] \) para \( k \geq i+1 \). \( A[i] \) é
            menor de \( A[i \dots A.length] \).</p>

    <p><strong>C. Invariante (linhas 1–4)</strong>: \( A[1 \dots i] \) ordenado (\( A[1] \leq \dots \leq A[i] \)), e \(
        A[k] \geq A[i] \) para \( k \geq i+1 \).</p>

    <p><strong>Prova</strong>:<br>
        1. <strong>Caso Base</strong>: Para \( i = 1 \), \( A[1 \dots 1] \) ordenado. Válido.<br>
        2. <strong>Passo Indutivo</strong>: Suponha que vale para \( i \). Laço interno garante \( A[i+1] \geq A[i] \),
        \( A[1 \dots i+1] \) ordenado. Válido.<br>
        3. <strong>Término</strong>: Para \( i = A.length \), \( A[1 \dots A.length] \) ordenado: \( A'[1] \leq \dots
        \leq A'[n] \).</p>

    <p><strong>D.</strong> Pior caso: \( \Theta(n^2) \). Igual à ordenação por inserção, mas inserção faz menos trocas e
        é melhor para vetores quase ordenados.</p>

</body>

</html>